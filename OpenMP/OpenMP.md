# Лабораторная работа №1

## Простые задачи
<i>NB! Задачи №1 и №2 объединены в один файл.</i>

### Задача №1.
Написать программу где каждый поток печатает свой идентификатор, количество потоков всего и строчку «Hello World». Запустить программу с 8 потоками. Всегда ли вывод идентичен? Почему? 

Результат работы [программы](https://github.com/kStasya/Distributed_computing/blob/main/OpenMP/tasks%20No.%201-2.cpp):

<img src="https://user-images.githubusercontent.com/102433741/222807518-8709c048-2939-44bb-865b-e797007cb173.png" alt="results of task 1" width="500"/>

Вывод не упорядочен по номерам потоков (нитей), т.к. порядок выполнения потоков заранее неизвестен (+ нет ordered). 

### Задача №2.
Написать программу, в которой объявлен массив из 16000 элементов и инициализирован так, что значение элемента массива равно его порядковому номеру. Затем создайте результирующий массив, в котором (за исключением крайних элементов) будут средние значения исходного массива: 
b[i] = (a[i-1] + a[i] + a[i+1])/3.0.
Запустите программу с 8-ю процессами при различных типах распределения работ. 

Результат работы [программы](https://github.com/kStasya/Distributed_computing/blob/main/OpenMP/tasks%20No.%201-2.cpp):

<img src="https://user-images.githubusercontent.com/102433741/222811800-c2525055-83f3-498b-a65b-d46cd08b606a.png" alt="results of task 2 with schedule(static,1000)" width="500"/>

На скриншоте результат (вернее, его небольшая часть) при использовании schedule(static, 1000) для 2 циклов (инициализация массива a и инициализация массива b). Для каждого цикла потоки получили на выполнение итерации след. образом: 0 поток - от 0 до 999, 1 поток - от 1000 до 1999, и т.д. по аналогии (с 8000 начинается снова с 0 потока). 

<img src="https://user-images.githubusercontent.com/102433741/222813982-0b492bda-b6a4-4d4c-811d-608b5b659a9f.png" alt="results of task 2 with schedule(dynamic,1000)" width="500"/>

<img src="https://user-images.githubusercontent.com/102433741/222814177-13fda315-2c34-4d45-8f0f-421c1c2dfc06.png" alt="results of task 2 with schedule(guided)" width="500"/>

На первом скриншоте использовано schedule(dynamic, 1000), на втором - schedule(guided). На практике разницы между ними не увидела, т.к. размеры блоков для данной задачи получились одинаковыми. 

### Задача №4.
Напишите программу перемножения больших матриц. Сравните врем выполнения последовательной и параллельной программы на 2, 4, 8 потоках (процессорах).

Для примера взяты матрицы с элементами вида i + j + 1 (i - номер строки элемента, j - номер его столбца), т.е. в матрицах нет нулевых элементов.

Результат работы [программы](https://github.com/kStasya/Distributed_computing/blob/main/OpenMP/task%204.cpp):

<img src="https://user-images.githubusercontent.com/102433741/222815661-4249bc6d-cbcc-4e94-9900-ea2da362583b.png" alt="results of task 4" width="500"/>

Параллельное выполнение программы занимает больше времени по сравнению с последовательным выполнением.

## Основная задача
### Задача №2. 
Разработайте программу для задачи вычисления определенного интеграла с использованием метода трапеций. 

<i>Цель работы</i>: разработать программу для вычисления определенного интеграла методом трапеции и сравнить результаты при последовательном её выполнении и параллельной реализации с использованием OpenMP. 

Пусть для данной задачи определенный интеграл имеет вид: 

$$ \int_{x_0}^{x_n}\big(x^3 - 3\big)dx,  $$

где $x_0$ и $x_n$ являются вещественными и вводятся пользователем. 

Время в мкс посчитано для функций с циклом, где вычисляется сумма значений подынтегральной функции в узловых точках (за исключением нижнего и верхнего пределов интегрирования), а именно при последовательном выполнении цикла (далее в таблице отмечено как sequential) и при его параллельном вычислении с циклическим распределением итераций при 2, 4 и 8 потоках (далее в таблице отмечено как parallel).

Оптимизированы вычисления методом трапеции: значение подынтегральной функции на концах каждого частичного отрезка посчитано лишь единожды, т.к. при сдвиге на шаг правый конец предыдущего частичного отрезка становится левым концом нового частичного отрезка, но нет нужды вычислять значение подынтегральной функции в одной и той же точке 2 раза. 

Формулы для вычисления:

$$ \int_{x_0}^{x_n}f(x)dx = \big(f(x_0) + f(x_n) + 2\sum_{i=1}^{n-1}f(x_i) \big) \cdot \frac{h}{2} $$

$$ x_i = a + i \cdot h $$

$$ h = \frac{b - a}{n} $$

где n - число разбиений на частичные отрезки, h - шаг разбиения, $x_i$ - узлы интегрирования ($i = \overline{0, n}$).

Результаты работы [программы](https://github.com/kStasya/Distributed_computing/blob/main/OpenMP/integral%20calculation.cpp) при различных n и пределах интегрирования $x_0 = 1$, $x_n = 4$:

| n      | время работы функции (sequential), мкс | время работы функции (parallel, 2 потока), мкс | время работы функции (parallel, 4 потока), мкс | время работы функции (parallel, 8 потоков), мкс |
|  :---: |  :---:  |  :---: |  :---:  |  :---:  |
| 1000   | 56      | 260    | 202     | 231     |
| 2000   | 111     | 285    | 258     | 328     |
| 3000   | 222     | 326    | 263     | 348     |
| 4000   | 319     | 395    | 296     | 413     |
| 5000   | 443     | 454    | 330     | 416     |
| 10000  | 1135    | 804    | 550     | 567     |
| 15000  | 1658    | 1015   | 808     | 616     |
| 25000  | 2773    | 1606   | 937     | 537     |
| 50000  | 5326    | 856    | 529     | 347     |

По значениям в таблице можно увидеть, что при $n < 4000$ лучше всего использовать функцию с последовательным выполнением цикла, а начиная приблизительно с $n = 4000$ время выполнения меньше всего при использовании 4 потоков. При $n > 15000$ наиболее оптимальным вариантом является использование 8 потоков для функции с циклическим распределением итераций, причем время работы функции сокращено более чем в 2 раза по сравнению с функцией с последовательно выполняемым циклом.  
